// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: recover_service.proto

#include "recover_service.pb.h"
#include "recover_service.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace recoverer {

static const char* recover_service_method_names[] = {
  "/recoverer.recover_service/TellVersion",
  "/recoverer.recover_service/Chunk2Send",
  "/recoverer.recover_service/SendChunk",
  "/recoverer.recover_service/KeepAlive",
  "/recoverer.recover_service/RecoverServ",
};

std::unique_ptr< recover_service::Stub> recover_service::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< recover_service::Stub> stub(new recover_service::Stub(channel));
  return stub;
}

recover_service::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_TellVersion_(recover_service_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Chunk2Send_(recover_service_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SendChunk_(recover_service_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_KeepAlive_(recover_service_method_names[3], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_RecoverServ_(recover_service_method_names[4], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status recover_service::Stub::TellVersion(::grpc::ClientContext* context, const ::recoverer::Version& request, ::recoverer::Reply* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_TellVersion_, context, request, response);
}

void recover_service::Stub::experimental_async::TellVersion(::grpc::ClientContext* context, const ::recoverer::Version* request, ::recoverer::Reply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_TellVersion_, context, request, response, std::move(f));
}

void recover_service::Stub::experimental_async::TellVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::recoverer::Reply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_TellVersion_, context, request, response, std::move(f));
}

void recover_service::Stub::experimental_async::TellVersion(::grpc::ClientContext* context, const ::recoverer::Version* request, ::recoverer::Reply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_TellVersion_, context, request, response, reactor);
}

void recover_service::Stub::experimental_async::TellVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::recoverer::Reply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_TellVersion_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::recoverer::Reply>* recover_service::Stub::AsyncTellVersionRaw(::grpc::ClientContext* context, const ::recoverer::Version& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::recoverer::Reply>::Create(channel_.get(), cq, rpcmethod_TellVersion_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::recoverer::Reply>* recover_service::Stub::PrepareAsyncTellVersionRaw(::grpc::ClientContext* context, const ::recoverer::Version& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::recoverer::Reply>::Create(channel_.get(), cq, rpcmethod_TellVersion_, context, request, false);
}

::grpc::Status recover_service::Stub::Chunk2Send(::grpc::ClientContext* context, const ::recoverer::Image& request, ::recoverer::ChunkList* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Chunk2Send_, context, request, response);
}

void recover_service::Stub::experimental_async::Chunk2Send(::grpc::ClientContext* context, const ::recoverer::Image* request, ::recoverer::ChunkList* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Chunk2Send_, context, request, response, std::move(f));
}

void recover_service::Stub::experimental_async::Chunk2Send(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::recoverer::ChunkList* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Chunk2Send_, context, request, response, std::move(f));
}

void recover_service::Stub::experimental_async::Chunk2Send(::grpc::ClientContext* context, const ::recoverer::Image* request, ::recoverer::ChunkList* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Chunk2Send_, context, request, response, reactor);
}

void recover_service::Stub::experimental_async::Chunk2Send(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::recoverer::ChunkList* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Chunk2Send_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::recoverer::ChunkList>* recover_service::Stub::AsyncChunk2SendRaw(::grpc::ClientContext* context, const ::recoverer::Image& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::recoverer::ChunkList>::Create(channel_.get(), cq, rpcmethod_Chunk2Send_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::recoverer::ChunkList>* recover_service::Stub::PrepareAsyncChunk2SendRaw(::grpc::ClientContext* context, const ::recoverer::Image& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::recoverer::ChunkList>::Create(channel_.get(), cq, rpcmethod_Chunk2Send_, context, request, false);
}

::grpc::Status recover_service::Stub::SendChunk(::grpc::ClientContext* context, const ::recoverer::Chunk& request, ::recoverer::Reply* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SendChunk_, context, request, response);
}

void recover_service::Stub::experimental_async::SendChunk(::grpc::ClientContext* context, const ::recoverer::Chunk* request, ::recoverer::Reply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SendChunk_, context, request, response, std::move(f));
}

void recover_service::Stub::experimental_async::SendChunk(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::recoverer::Reply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SendChunk_, context, request, response, std::move(f));
}

void recover_service::Stub::experimental_async::SendChunk(::grpc::ClientContext* context, const ::recoverer::Chunk* request, ::recoverer::Reply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SendChunk_, context, request, response, reactor);
}

void recover_service::Stub::experimental_async::SendChunk(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::recoverer::Reply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SendChunk_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::recoverer::Reply>* recover_service::Stub::AsyncSendChunkRaw(::grpc::ClientContext* context, const ::recoverer::Chunk& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::recoverer::Reply>::Create(channel_.get(), cq, rpcmethod_SendChunk_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::recoverer::Reply>* recover_service::Stub::PrepareAsyncSendChunkRaw(::grpc::ClientContext* context, const ::recoverer::Chunk& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::recoverer::Reply>::Create(channel_.get(), cq, rpcmethod_SendChunk_, context, request, false);
}

::grpc::Status recover_service::Stub::KeepAlive(::grpc::ClientContext* context, const ::recoverer::Reply& request, ::recoverer::Reply* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_KeepAlive_, context, request, response);
}

void recover_service::Stub::experimental_async::KeepAlive(::grpc::ClientContext* context, const ::recoverer::Reply* request, ::recoverer::Reply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_KeepAlive_, context, request, response, std::move(f));
}

void recover_service::Stub::experimental_async::KeepAlive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::recoverer::Reply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_KeepAlive_, context, request, response, std::move(f));
}

void recover_service::Stub::experimental_async::KeepAlive(::grpc::ClientContext* context, const ::recoverer::Reply* request, ::recoverer::Reply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_KeepAlive_, context, request, response, reactor);
}

void recover_service::Stub::experimental_async::KeepAlive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::recoverer::Reply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_KeepAlive_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::recoverer::Reply>* recover_service::Stub::AsyncKeepAliveRaw(::grpc::ClientContext* context, const ::recoverer::Reply& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::recoverer::Reply>::Create(channel_.get(), cq, rpcmethod_KeepAlive_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::recoverer::Reply>* recover_service::Stub::PrepareAsyncKeepAliveRaw(::grpc::ClientContext* context, const ::recoverer::Reply& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::recoverer::Reply>::Create(channel_.get(), cq, rpcmethod_KeepAlive_, context, request, false);
}

::grpc::Status recover_service::Stub::RecoverServ(::grpc::ClientContext* context, const ::recoverer::Image& request, ::recoverer::Reply* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_RecoverServ_, context, request, response);
}

void recover_service::Stub::experimental_async::RecoverServ(::grpc::ClientContext* context, const ::recoverer::Image* request, ::recoverer::Reply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_RecoverServ_, context, request, response, std::move(f));
}

void recover_service::Stub::experimental_async::RecoverServ(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::recoverer::Reply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_RecoverServ_, context, request, response, std::move(f));
}

void recover_service::Stub::experimental_async::RecoverServ(::grpc::ClientContext* context, const ::recoverer::Image* request, ::recoverer::Reply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_RecoverServ_, context, request, response, reactor);
}

void recover_service::Stub::experimental_async::RecoverServ(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::recoverer::Reply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_RecoverServ_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::recoverer::Reply>* recover_service::Stub::AsyncRecoverServRaw(::grpc::ClientContext* context, const ::recoverer::Image& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::recoverer::Reply>::Create(channel_.get(), cq, rpcmethod_RecoverServ_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::recoverer::Reply>* recover_service::Stub::PrepareAsyncRecoverServRaw(::grpc::ClientContext* context, const ::recoverer::Image& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::recoverer::Reply>::Create(channel_.get(), cq, rpcmethod_RecoverServ_, context, request, false);
}

recover_service::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      recover_service_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< recover_service::Service, ::recoverer::Version, ::recoverer::Reply>(
          [](recover_service::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::recoverer::Version* req,
             ::recoverer::Reply* resp) {
               return service->TellVersion(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      recover_service_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< recover_service::Service, ::recoverer::Image, ::recoverer::ChunkList>(
          [](recover_service::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::recoverer::Image* req,
             ::recoverer::ChunkList* resp) {
               return service->Chunk2Send(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      recover_service_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< recover_service::Service, ::recoverer::Chunk, ::recoverer::Reply>(
          [](recover_service::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::recoverer::Chunk* req,
             ::recoverer::Reply* resp) {
               return service->SendChunk(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      recover_service_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< recover_service::Service, ::recoverer::Reply, ::recoverer::Reply>(
          [](recover_service::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::recoverer::Reply* req,
             ::recoverer::Reply* resp) {
               return service->KeepAlive(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      recover_service_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< recover_service::Service, ::recoverer::Image, ::recoverer::Reply>(
          [](recover_service::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::recoverer::Image* req,
             ::recoverer::Reply* resp) {
               return service->RecoverServ(ctx, req, resp);
             }, this)));
}

recover_service::Service::~Service() {
}

::grpc::Status recover_service::Service::TellVersion(::grpc::ServerContext* context, const ::recoverer::Version* request, ::recoverer::Reply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status recover_service::Service::Chunk2Send(::grpc::ServerContext* context, const ::recoverer::Image* request, ::recoverer::ChunkList* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status recover_service::Service::SendChunk(::grpc::ServerContext* context, const ::recoverer::Chunk* request, ::recoverer::Reply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status recover_service::Service::KeepAlive(::grpc::ServerContext* context, const ::recoverer::Reply* request, ::recoverer::Reply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status recover_service::Service::RecoverServ(::grpc::ServerContext* context, const ::recoverer::Image* request, ::recoverer::Reply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace recoverer

